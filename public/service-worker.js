const CACHE_NAME = 'yaygara-v1.2.6'; const CORE_ASSETS = ['/', '/index.html', '/tr/', '/en/', '/manifest.json', '/decks-manifest.json', '/locales/tr.json', '/locales/en.json', '/icons/favicon.svg', '/icons/icon-192x192.png', '/icons/icon-512x512.png', '/yaygara.svg']; self.addEventListener('install', (event) => { event.waitUntil(caches.open(CACHE_NAME).then(async (cache) => { console.log('[SW] Pre-caching assets'); await Promise.all(CORE_ASSETS.map(url => { return cache.add(url).catch(err => console.warn(`[SW] Failed to cache ${url}:`, err)) })); try { const decksRes = await fetch('/decks-manifest.json'); if (decksRes.ok) { const decks = await decksRes.json(); const deckUrls = decks.map(filename => `/decks/${filename}`); await Promise.all(deckUrls.map(url => cache.add(url).catch(err => console.warn(`[SW] Failed to cache deck ${url}:`, err)))) } } catch (err) { console.error('[SW] Failed to fetch decks manifest during install:', err) } try { const assetsRes = await fetch('/assets-manifest.json'); if (assetsRes.ok) { const assets = await assetsRes.json(); await Promise.all(assets.map(url => cache.add(url).catch(err => console.warn(`[SW] Failed to cache production asset ${url}:`, err)))) } } catch (err) { console.log('[SW] No assets-manifest.json found (likely dev mode)') } })); self.skipWaiting() }); self.addEventListener('activate', (event) => { event.waitUntil(caches.keys().then((cacheNames) => { return Promise.all(cacheNames.map((cacheName) => { if (cacheName !== CACHE_NAME) { console.log('[SW] Deleting old cache:', cacheName); return caches.delete(cacheName) } })) })); return self.clients.claim() }); async function staleWhileRevalidate(request) { const cache = await caches.open(CACHE_NAME); const cachedResponse = await cache.match(request); const isCacheableScheme = request.url.startsWith('http:') || request.url.startsWith('https:'); const networkPromise = fetch(request).then((networkResponse) => { if (networkResponse && networkResponse.status === 200 && isCacheableScheme) { cache.put(request, networkResponse.clone()) } return networkResponse }).catch(() => { }); return cachedResponse || networkPromise } async function cacheFirst(request) { const cache = await caches.open(CACHE_NAME); const cachedResponse = await cache.match(request); if (cachedResponse) return cachedResponse; try { const networkResponse = await fetch(request); const isCacheableScheme = request.url.startsWith('http:') || request.url.startsWith('https:'); if (networkResponse && networkResponse.status === 200 && isCacheableScheme) { cache.put(request, networkResponse.clone()) } return networkResponse } catch (err) { return null } } self.addEventListener('fetch', (event) => { const url = new URL(event.request.url); if (event.request.mode === 'navigate') { event.respondWith(staleWhileRevalidate(event.request).then(response => { return response || caches.match('/index.html') || caches.match('/') || caches.match('/tr/') || caches.match('/en/') })); return } const isHashedAsset = url.pathname.includes('/assets/'); const isStaticFile = url.pathname.includes('/icons/') || url.pathname.includes('/decks/') || url.pathname.endsWith('.png') || url.pathname.endsWith('.svg') || url.pathname.endsWith('.ico'); if (isHashedAsset || isStaticFile) { event.respondWith(cacheFirst(event.request)); return } const isUpdateTrigger = url.pathname.endsWith('.json'); if (isUpdateTrigger) { event.respondWith(staleWhileRevalidate(event.request)); return } event.respondWith(staleWhileRevalidate(event.request).catch(() => { return caches.match(event.request) })) });